__SAR_DATA::{"power":true,"scripts":[{"code":"\n// Send request to extension\nfunction apiExt(url, method = \"GET\", headers = {}, body = null) {\n  return new Promise((resolve) => {\n    window.addEventListener(\"message\", function handler(event) {\n      if (event.source !== window) return;\n      if (event.data.type === \"API_RESPONSE_FROM_EXTENSION\") {\n        window.removeEventListener(\"message\", handler);\n        resolve(event.data.response);\n      }\n    });\n\n    window.postMessage({\n      type: \"API_REQUEST_FROM_PAGE\",\n      url,\n      method,\n      headers,\n      body,\n    }, \"*\");\n  });\n}\nwindow.apiExt = apiExt\n// Example usage\n// callApi(\"https://jsonplaceholder.typicode.com/posts\", \"GET\")\n//   .then((res) => console.log(\"Got response via extension:\", res));\n","enable":false,"host":"","id":22,"name":"Helpers","src":"","type":"snippet"},{"code":"// Shared defaults\n// 11434\nconst OLLAMA_BASE = \"http://localhost:11434\";\nconst DEFAULT_MODEL = \"llama3.2\";\n// const DEFAULT_MODEL = \"gemma3:12b\";\n\n// Helper: safe model fallback\nconst pickModel = (m) => m ?? DEFAULT_MODEL;\n\n// Optional: extract <answer>...</answer> for chat responses\nfunction extractAnswerTag(text) {\n  if (!text) return \"\";\n  const start = text.indexOf(\"<answer>\");\n  const end = text.indexOf(\"</answer>\");\n  if (start !== -1 && end !== -1 && end > start) {\n    return text.slice(start + 9, end).trim();\n  }\n  return text.trim();\n}\n\n/**\n * Simple completion call (/api/generate)\n */\nasync function askOllama(prompt, options = {}) {\n  const payload = {\n    model: pickModel(options.model),\n    prompt,\n    stream: options.stream ?? false,\n    ...options,\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/generate`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n    return res; // whatever your apiExt returns (likely parsed JSON)\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/generate:\", err);\n    throw err;\n  }\n}\n\n/**\n * Chat call (/api/chat) using apiExt, mirroring askOllama style\n * @param {{question: string, content: string}} chatInput\n * @param {object} options - same pattern as askOllama\n */\nasync function askOllamaChat(chatInput, options = {}) {\n  const { question, content } = chatInput;\n\n  const messages = [\n    {\n      role: \"system\",\n      content: [\n        // \"You extract answers from the provided CONTENT only.\",\n        \"You extract answers from the provided CONTENT.\",\n        // \"Be concise: <= 100 characters.\",\n        // \"If not found in CONTENT, reply: Not found.\",\n        // \"If not found in CONTENT, reply: No results.\",\n        // \"Output MUST be wrapped in <answer>...</answer> with nothing else.\"\n      ].join(\" \")\n    },\n    {\n      role: \"user\",\n      content: [\n        \"### CONTENT START\",\n        content,\n        \"### CONTENT END\",\n        \"\",\n        \"### QUESTION\",\n        question\n      ].join(\"\\n\")\n    }\n  ];\n\n  const payload = {\n    model: pickModel(options.model),\n    stream: options.stream ?? false,\n    options: {\n      temperature: 0.2,\n      num_ctx: 8192,\n      stop: [\"</answer>\"],\n      ...(options.options || {})\n    },\n    messages,\n    ...options, // allow overriding top-level fields if you really want\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/chat`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n\n    // If you want to directly return parsed text like askOllama does,\n    // you can normalize here. Otherwise, return the raw `res`.\n    // Uncomment to normalize:\n    //\n    // const contentTxt = res?.message?.content ?? \"\";\n    // return { ...res, extracted: extractAnswerTag(contentTxt) };\n\n    return res;\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/chat:\", err);\n    throw err;\n  }\n}\n\n\n\n\n\n// write here code that injects interface on html page with field for user prompt and a box for stream response from llm\n(() => {\n  const askAI = askOllamaChat;\n\n  // ---------- UI Styles ----------\n    // .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    // width:min(520px,95vw);background:#111827;color:#e5e7eb;border:1px solid #1f2937;\n    // border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    // user-select:none}\n  const css = `\n  .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    width:min(520px,95vw);background:#111827dd;color:#e5e7eb;border:1px solid #1f2937;backdrop-filter:blur(7px);\n    border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    user-select:none}\n  .agent-ui.dragging{opacity:.95}\n  .agent-ui .hdr{display:flex;align-items:center;gap:8px;padding:10px 12px;border-bottom:1px solid #1f2937;cursor:move}\n  .agent-ui .title{font-weight:600}\n  .agent-ui .body{padding:12px;display:flex;flex-direction:column;gap:10px; user-select:text}\n  .agent-ui textarea{width:initial;min-height:72px;resize:vertical;background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:10px;outline:none; font-family: sans-serif}\n  .agent-ui .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n  .agent-ui button{background:#2563eb;border:none;color:white;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer; transition: box-shadow 0.15s ease-in-out}\n  .agent-ui button:hover{background:#2563eb;filter: brightness(120%); box-shadow: 0 0 0 2px #6591f1}\n  .agent-ui button:active{background:#2563eb;filter: brightness(80%); box-shadow: 0 0 0 1px #6591f1}\n  .agent-ui button.ghost{background:transparent;color:#cbd5e1;border:1px solid #334155}\n  .agent-ui pre{background:#0b1220;border:1px solid #334155;border-radius:10px;padding:12px;max-height:40vh;overflow:auto;white-space:pre-wrap;word-wrap:break-word}\n  `;\n\n  const style = document.createElement('style');\n  style.textContent = css;\n  document.body.appendChild(style);\n\n  const box = document.createElement('div');\n  box.className = 'agent-ui';\n  box.id = 'blower__';\n  box.style.display='none'\n  box.innerHTML = `\n    <div class=\"hdr\">\n      <div class=\"title\">Blower</div>\n      <div style=\"margin-left:auto;display:flex;gap:6px\">\n        <button class=\"ghost\" data-action=\"clear\">Clear</button>\n        <button class=\"ghost\" data-action=\"close\">âœ•</button>\n      </div>\n    </div>\n    <div class=\"body\">\n      <div style=\"display:flex\"></div>\n      <textarea placeholder=\"Ask me anything...\"></textarea>\n      <div class=\"row\">\n        <button data-action=\"start\" style=\"width: 100%\">Go</button>\n      </div>\n      <pre id=\"ollama-output\">ðŸ”Ž Ready</pre>\n    </div>\n  `;\n  document.body.appendChild(box);\n\n  // Restore saved position (if any)\n  try {\n    const saved = JSON.parse(localStorage.getItem('agent-ui-pos') || '{}');\n    if (typeof saved.left === 'number' && typeof saved.top === 'number') {\n      box.style.left = saved.left + 'px';\n      box.style.top  = saved.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n    }\n    const savedVis = localStorage.getItem('agent-ui-visible');\n    if (savedVis === 'hidden') box.style.display = 'none';\n  } catch {}\n\n  // ---------- Helpers ----------\n  const $ = (sel) => box.querySelector(sel);\n  const textarea = $('textarea');\n  const startBtn = $('[data-action=\"start\"]');\n  const clearBtn = $('[data-action=\"clear\"]');\n  const closeBtn = $('[data-action=\"close\"]');\n  const out = $('#ollama-output');\n  const header = box.querySelector('.hdr');\n\n  // Drag state\n  let dragging = false;\n  let startX = 0, startY = 0;\n  let boxStartLeft = 0, boxStartTop = 0;\n  let usingLeftTop = false;\n\n  const clamp = (val, min, max) => Math.min(Math.max(val, min), max);\n\n  function ensureLeftTopMode() {\n    if (!usingLeftTop) {\n      const r = box.getBoundingClientRect();\n      box.style.left = r.left + 'px';\n      box.style.top  = r.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n      usingLeftTop = true;\n    }\n  }\n\n  function onPointerDown(clientX, clientY) {\n    dragging = true;\n    ensureLeftTopMode();\n    const r = box.getBoundingClientRect();\n    startX = clientX;\n    startY = clientY;\n    boxStartLeft = r.left;\n    boxStartTop  = r.top;\n    box.classList.add('dragging');\n    // Prevent text selection while dragging\n    document.body.style.userSelect = 'none';\n  }\n\n  function onPointerMove(clientX, clientY) {\n    if (!dragging) return;\n    const dx = clientX - startX;\n    const dy = clientY - startY;\n\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const r = box.getBoundingClientRect();\n    const newLeft = clamp(boxStartLeft + dx, 6, vw - r.width - 6);\n    const newTop  = clamp(boxStartTop  + dy,  6, vh - r.height - 6);\n\n    box.style.left = newLeft + 'px';\n    box.style.top  = newTop  + 'px';\n  }\n\n  function onPointerUp() {\n    if (!dragging) return;\n    dragging = false;\n    box.classList.remove('dragging');\n    document.body.style.userSelect = '';\n    // persist position\n    try {\n      const r = box.getBoundingClientRect();\n      localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(r.left), top: Math.round(r.top) }));\n    } catch {}\n  }\n\n  // Mouse events\n  header.addEventListener('mousedown', (e) => {\n    if (e.button !== 0) return;\n    onPointerDown(e.clientX, e.clientY);\n    e.preventDefault();\n  });\n  window.addEventListener('mousemove', (e) => onPointerMove(e.clientX, e.clientY));\n  window.addEventListener('mouseup', onPointerUp);\n\n  // Touch events\n  header.addEventListener('touchstart', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerDown(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchmove', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerMove(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchend', onPointerUp);\n\n  // Keep box inside viewport on resize\n  window.addEventListener('resize', () => {\n    const r = box.getBoundingClientRect();\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const left = clamp(r.left, 6, vw - r.width - 6);\n    const top  = clamp(r.top,  6, vh - r.height - 6);\n    box.style.left = left + 'px';\n    box.style.top  = top  + 'px';\n    box.style.right = 'auto';\n    box.style.bottom = 'auto';\n    usingLeftTop = true;\n    try {\n      localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(left), top: Math.round(top) }));\n    } catch {}\n  });\n\n  // Toggle visibility with Ctrl+Shift+H (or Cmd+Shift+H on mac)\n  function toggleBoxVisibility() {\n    const hidden = box.style.display === 'none';\n    box.style.display = hidden ? '' : 'none';\n    try {\n      localStorage.setItem('agent-ui-visible', hidden ? 'shown' : 'hidden');\n    } catch {}\n  }\n  document.addEventListener('keydown', (e) => {\n    const isH = e.key && e.key.toLowerCase() === 'x';\n    if (isH && e.shiftKey && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      toggleBoxVisibility();\n    }\n  });\nfunction processPage() {\n  // ---- 1) Clone the DOM so we never mutate the live page ----\n  const domBody = document.body.cloneNode(true);\n  const doc = document; // baseURI, title, metas come from the live doc\n\n  // ---- 2) Drop obvious junk early (scripts, styles, embeds, tracking, etc.) ----\n  const hardRemoveSelectors = [\n    'script','noscript','style',\n    // 'template',\n    // 'link[rel=\"preload\"]','link[rel=\"modulepreload\"]',\n    // 'iframe',\n    'object','embed','svg','canvas',\n    // 'form','button','select','input','textarea',\n    'video','audio','picture','source',\n    // common boilerplate / chrome\n    'aside',\n    // 'nav','footer','header',\n  ].join(',');\n\n  domBody.querySelectorAll(hardRemoveSelectors).forEach(el => el.remove());\n\n    // Remove specific known element\n  const blower = domBody.querySelector('#blower__');\n  if (blower) blower.remove();\n\n\n  // ---- 3) Remove elements by role/semantics or nuisance-y id/class patterns ----\n  const nuisanceRe = /(cookie|consent|gdpr|banner|promo|subscribe|signup|newsletter|metered|paywall|modal|dialog|overlay|popover|tooltip|share|social|related|recommend(ed|ations)?|breadcrumb|nav|sidebar|footer|header|ad(s|vert|vertisement)?|sponsor|tracking|beacon|outbrain|taboola)/i;\n  domBody.querySelectorAll('[role], [id], [class]').forEach(el => {\n    const role = el.getAttribute('role') || '';\n    const id = el.id || '';\n    const cls = el.className || '';\n    if (\n      /^(navigation|banner|complementary|contentinfo|search|dialog|alertdialog|menu|menubar|tablist|toolbar)$/i.test(role) ||\n      nuisanceRe.test(id) ||\n      nuisanceRe.test(String(cls))\n    ) {\n      el.remove();\n    }\n  });\n\n  // ---- 4) Remove hidden/visually suppressed elements ----\n  domBody.querySelectorAll('*').forEach(el => {\n    const s = el.getAttribute('style') || '';\n    if (\n      el.hidden ||\n      el.getAttribute('aria-hidden') === 'true' ||\n      /\\bdisplay\\s*:\\s*none\\b/i.test(s) ||\n      /\\bvisibility\\s*:\\s*hidden\\b/i.test(s) ||\n      /\\bopacity\\s*:\\s*0(\\.0+)?\\b/i.test(s)\n    ) {\n      el.remove();\n    }\n  });\n\n  \n\n  // ---- 5) Remove all HTML comments ----\n  {\n    const walker = document.createTreeWalker(domBody, NodeFilter.SHOW_COMMENT, null, false);\n    const toRemove = [];\n    while (walker.nextNode()) toRemove.push(walker.currentNode);\n    toRemove.forEach(node => node.remove());\n  }\n\n  // ---- 6) Convert images to readable alt text (or drop if useless) ----\n  domBody.querySelectorAll('img').forEach(img => {\n    const alt = (img.getAttribute('alt') || '').trim();\n    if (alt) {\n      img.replaceWith(document.createTextNode(`[Image: ${alt}]`));\n    } else {\n      img.remove();\n    }\n  });\n\n  \n\n  // ---- 7) Expand links to include their (absolute) URLs next to the anchor text ----\n  // domBody.querySelectorAll('a[href]').forEach(a => {\n  //   const href = a.getAttribute('href');\n  //   let abs = '';\n  //   try { abs = new URL(href, doc.baseURI).href; } catch { /* ignore */ }\n  //   const text = (a.textContent || '').trim();\n  //   const label = text && abs ? `${text} (${abs})` : (abs || text);\n  //   a.replaceWith(document.createTextNode(label || ''));\n  // });\n\n  // ---- 8) Light structural flattening: remove leftover UI chrome containers ----\n  // (but keep their text content by unwrapping vs. outright removing)\n  // const unwrapSelectors = ['section','article','main','div','span'];\n  // domBody.querySelectorAll(unwrapSelectors.join(',')).forEach(el => {\n  //   // unwrap shallow, but only if it has no obviously interactive/widgety descendants now\n  //   if (!el.querySelector('button,select,input,textarea,video,audio,iframe,object,embed,svg,canvas')) {\n  //     while (el.firstChild) el.parentNode.insertBefore(el.firstChild, el);\n  //     el.remove();\n  //   }\n  // });\n\n  // ---- 9) Extract meaningful text with gentle block separation ----\n  // Prefer text from common content blocks; fallback to full innerText.\n  const blocks = Array.from(domBody.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,code,table,thead,tbody,tfoot,tr,th,td,caption,span'))\n    .map(el => el.innerText.trim())\n    .filter(Boolean);\n\n  let bodyText = (blocks.length ? blocks.join('\\n\\n') : domBody.innerText || '')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/[ \\t]+\\n/g, '\\n')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n\n    \n\n  // ---- 10) Prepend page metadata (title, canonical URL, description) ----\n  const title = (doc.querySelector('meta[property=\"og:title\"]')?.content || doc.title || '').trim();\n  const canonical = (doc.querySelector('link[rel=\"canonical\"]')?.href || doc.baseURI || '').trim();\n  const description = (doc.querySelector('meta[name=\"description\"]')?.content ||\n                       doc.querySelector('meta[property=\"og:description\"]')?.content || '').trim();\n\n  const headerLines = [];\n  if (title) headerLines.push(`# ${title}`);\n  if (canonical) headerLines.push(canonical);\n  if (description) headerLines.push(`\\n${description}`);\n  const header = headerLines.join('\\n');\n\n  const finalText = [header, bodyText].filter(Boolean).join('\\n\\n').trim();\n\n  return finalText;\n}\nconsole.log(processPage())\n  // ---------- Core ----------\n  async function runPrompt() {\n    const prompt_ = textarea.value.trim();\n    \n\n\n    const content_ = processPage()\n      // .split('\\n')\n      // .map(x => x.length > 100 ? null : x)\n      // .filter(x => x)\n      // .join(' ');\n      console.log(content_)\n\n    let prompt_old = `\n      You are an assistant that extracts information from a webpage. Be short with the answer. Max 50 characters. \n      User question: \"${prompt_}\"  \n\n      Webpage content:  \n      ${content_}\n    `;\n\n    if (!prompt_) {\n      textarea.focus();\n      return;\n    }\n    out.textContent = 'â³ Thinking...';\n    startBtn.disabled = true;\n    textarea.disabled = true;\n\n\n    let question = prompt_;\n    let content = content_;\n\n    try {\n      const res = await askAI({ question, content });\n      console.log(res,'res')\n      out.textContent =\n        typeof res === 'string'\n          ? res\n          : JSON.parse(res.body).message.content;\n    } catch (err) {\n      console.error(err);\n      out.textContent = 'âŒ Error: ' + err.message;\n    } finally {\n      startBtn.disabled = false;\n      textarea.disabled = false;\n    }\n  }\n\n  // ---------- Events ----------\n  startBtn.addEventListener('click', runPrompt);\n  textarea.addEventListener('keydown', (e) => {\n    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {\n      e.preventDefault();\n      runPrompt();\n    }\n  });\n  clearBtn.addEventListener('click', () => { out.textContent = 'ðŸ”Ž Ready'; });\n  closeBtn.addEventListener('click', () => { toggleBoxVisibility(); return; box.remove(); style.remove(); });\n})();\n\n","enable":false,"host":"","id":23,"name":"LLM","src":"","type":"snippet"},{"code":"// example.js\nasync function askOllama(prompt) {\n//   const response = await fetch(\"https://localhost:11434/api/generate\", {\n  const response = await fetch(\"http://localhost:3000/api/generate\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      model: \"llama3.2\",   // name of the model you pulled\n      prompt: prompt,      // the text you want to send\n      stream: false        // set true if you want streaming responses\n    })\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! Status: ${response.status}`);\n    alert(response.status)\n  }\n\n  const data = await response.json();\n  return data.response;\n}\n\n// Example usage\naskOllama(\"Write me a haiku about the sea.\")\n  .then(answer => console.log(\"Ollama says:\", answer))\n  .catch(err => console.error(\"Error:\", err));\n","enable":false,"host":"","id":21,"name":"Script21","src":"","type":"snippet"},{"code":"// A simple function that greets a user\nfunction greet(name) {\n  return `Hello, ${name}! ðŸ‘‹`;\n}\n\n// Call the function\nconsole.log(greet(\"Alice\")); // Output: Hello, Alice!\nconsole.log(greet(\"Bob\"));   // Output: Hello, Bob!\n","enable":false,"host":"","id":0,"name":"hello script","src":"","type":"snippet"},{"code":"let container\nlet prices\n\n// Create total element\nlet totalEl = document.createElement('h4');\ntotalEl.style.padding = '5px';\n// totalEl.style.filter = 'invert(1)';\ntotalEl.style.borderRadius = '6px';\ntotalEl.style.color = 'white';\ntotalEl.style.background = 'black';\ntotalEl.style.border = '2px solid white';\ntotalEl.style.width = 'fit-content';\ntotalEl.style.position = 'fixed'\n// totalEl.style.bottom = '20px'\n// totalEl.style.left = '20px'\ntotalEl.style.top = '1px'\ntotalEl.style.left = '50vw'\ntotalEl.style.transform = 'translate(-50%,50%)'\ntotalEl.style.zIndex = '1000'\n\n\ndocument.querySelector('#list-header').appendChild(totalEl);\n\nfunction invert(e, index) {\n    if (e && e.ctrlKey && e.shiftKey) {\n        prices.forEach((p, i) => {\n            let checkbox = p.parentElement.querySelector(`.price-check-${i}`);\n            checkbox.checked = true\n        });\n        return\n    }\n    if (e && e.ctrlKey) {\n        prices.forEach((p, i) => {\n            let checkbox = p.parentElement.querySelector(`.price-check-${i}`);\n            if (index != i)\n                checkbox.click()\n        });\n    }\n    recalcTotal()\n}\n\n// Function to recalc total\nfunction recalcTotal() {\n    const priceSymbol = (document.querySelector('.a-price-symbol') || '').innerText ||\n        (Array(...document.querySelectorAll('.a-price > .a-offscreen'))\n            .map(x => x.innerText).filter(x => x)[0] || '')\n            .split('').slice(-1)[0] || 'EUR'\n\n    let total = 0;\n    prices.forEach((p, i) => {\n        let checkbox = p.parentElement.querySelector(`.price-check-${i}`);\n        if (checkbox && checkbox.checked) {\n            let val = parseFloat(\n                p.innerText\n                    .split('')\n                    .slice(0, -2)\n                    .join('')\n                    .replace(',', '.')\n            );\n            if (!isNaN(val)) total += val;\n            prices[i].closest('span.a-list-item').style.opacity = ''\n            prices[i].closest('span.a-list-item').style.filter = ''\n        }\n        else {\n            prices[i].closest('span.a-list-item').style.opacity = '0.6'\n            prices[i].closest('span.a-list-item').style.filter = 'brightness(100%)'\n        }\n    });\n    totalEl.innerText = `Total: ${total.toFixed(2)} ${priceSymbol}`;\n}\n\n\nfunction init() {\n    waitMsg()\n\n    let intv = setInterval(() => {\n        container = document.querySelector('#g-items') || document.querySelector('#g-items-grid');\n        let spinner = document.querySelector('.a-spinner-wrapper.wl-see-more-spinner.g-visible-js')\n        if (!spinner) {\n            prices = container.querySelectorAll('.a-offscreen');\n            // Add checkboxes next to each price\n            prices.forEach((p, i) => {\n                let checkbox = document.createElement('input');\n                checkbox.type = 'checkbox';\n                checkbox.className = `price-check-${i}`;\n                checkbox.checked = true; // default: include all\n                checkbox.style.margin = '-2px 4px 5px 0px';\n                checkbox.style.zoom = '2'\n                // checkbox.style.zIndex='2000'\n                checkbox.addEventListener('change', recalcTotal);\n                checkbox.addEventListener('click', (e) => { invert(e, i) });\n                p.insertAdjacentElement('afterend', checkbox);\n            });\n            recalcTotal();\n            document.body.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n            clearInterval(intv)\n        } else {\n            container.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n        }\n    }, 500)\n}\n\n// Initial calculation\ninit()\n\nfunction waitMsg() {\n    totalEl.innerText = 'Waiting to load all items in list...'\n}\n\n['#grid-view-switcher', '#list-view-switcher'].forEach(sel => {\n  document.querySelector(sel).addEventListener('click', () => {\n    waitMsg()\n    setTimeout(init, 1500)\n  })\n})\n","enable":false,"host":"amazon.it, amazon.com","id":19,"name":"prezzo totale lista amazon2","src":"","type":"snippet"},{"code":"let a = (document.querySelector('#g-items') || document.querySelector('#g-items-grid')).querySelectorAll('.a-offscreen')\nlet total = Array(...a).map(x=>parseFloat(x.innerText.split('').slice(0,-2).join('').replace(',','.'))).reduce((a,b)=>a+b,0).toFixed(2)\n\nlet el = document.createElement('h4')\nel.innerText=`Total: ${total} EUR`\nel.style.padding='5px'\nel.style.filter='invert(1)'\nel.style.borderRadius='6px'\nel.style.color='black'\nel.style.background='white'\nel.style.width='fit-content'\ndocument.querySelector('#list-header').appendChild(el)","enable":false,"host":"amazon.it","id":3,"name":"prezzo totale lista amazon","src":"","type":"snippet"},{"code":"function loadScript(src, callback) {\n  const script = document.createElement('script');\n  script.src = src;\n  script.async = true;\n\n  script.onload = () => {\n    console.log(`${src} loaded successfully`);\n    if (callback) callback();\n  };\n\n  script.onerror = () => {\n    console.error(`Failed to load script: ${src}`);\n  };\n\n  document.head.appendChild(script);\n}\n\n// Example usage:\nloadScript('http://localhost:8080/js/applets/llm.js', () => {\n  console.log('Script is ready to use!');\n});\n","enable":true,"host":"","id":24,"name":"load from js file","src":"","type":"snippet"},{"code":"function loadScript(src, callback) {\n  const script = document.createElement('script');\n  script.src = src;\n  script.async = true;\n\n  script.onload = () => {\n    console.log(`${src} loaded successfully`);\n    if (callback) callback();\n  };\n\n  script.onerror = () => {\n    console.error(`Failed to load script: ${src}`);\n  };\n\n  document.head.appendChild(script);\n}\n\n// Example usage:\nloadScript('http://localhost:8080/llm.js', () => {\n  console.log('Script is ready to use!');\n});\n","enable":false,"host":"","id":25,"name":"Script25","src":"","type":"snippet"},{"code":"setInterval(()=>{console.log(window.ExtBridge,window.location.href)},2000)\n","enable":false,"host":"","id":26,"name":"Script25 (copy)","src":"","type":"snippet"},{"code":"function addIframe(url=\"https://amicidellapallavolo.it/\", width = \"600\", height = \"400\") {\n  const iframe = document.createElement(\"iframe\");\n  iframe.id='myFrame'\n  iframe.src = url;\n  iframe.width = width;\n  iframe.height = height;\n  iframe.style.border = \"1px solid #ccc\";\n  console.log(document.body, document.children, document.children[0])\n  document.body.appendChild(iframe);\n\n  \n\n//   iframe.onload = function () {\nsetTimeout(()=>{\naskTalkai({question: 'hi', content:''})\n},1111)\n\n//   };\n\n\n}\n\nasync function askTalkai(chatInput){\n    \nconst iframe_id_selector = '#myFrame'\n\nconst { question, content } = chatInput;\nlet a = await window.ExtBridge.grant(iframe_id_selector);\nconsole.log(a)\nconsole.log(document.querySelector(iframe_id_selector))\n\nlet prompt = `\nYou extract answers from the provided CONTENT.\n###CONTENT START\n\n${'..'||content}\n\n###CONTENT END\n\n###QUESTION\n\n${question}\n`\n\nconsole.log(prompt,)\n\n// 2) Run a page-world fetch inside that iframe (first-party cookies)\nconst res = await window.ExtBridge.call(iframe_id_selector, 'pageFetch', {\n  url: 'https://amicidellapallavolo.it',\n  init: {\n    method: 'GET',\n    // headers: {\n    //   'accept': 'application/json, text/event-stream',\n    //   'content-type': 'application/json'\n    // },\n    // body: JSON.stringify({\n    //   type: 'chat',\n    //   messagesHistory: [{ id: crypto.randomUUID(), from: 'you', content: prompt }],\n    //   settings: { model: 'gpt-4.1-nano', temperature: 0.7 }\n    // })\n  },\n  // optional: \"json\" to auto parse\n  responseType: 'text'\n});\nconsole.log('Result from iframe page-world:', res);\nreturn parseSSE(res.body)\n}\n\nsetTimeout(()=>{\nif(window.location.href==='https://www.google.com/')\n// if(window.location.href==='https://www.amicidellapallavolo.it/login.asp')\n// if(window.location.href==='about:blank')\naddIframe()\n},2222)\n\n","enable":false,"host":"","id":27,"name":"Script27","src":"","type":"snippet"},{"code":"function addIframe(url=\"https://amicidellapallavolo.it/\", width = \"600\", height = \"400\") {\n  const iframe = document.createElement(\"iframe\");\n  iframe.id='myFrame'\n  iframe.src = url;\n  iframe.width = width;\n  iframe.height = height;\n  iframe.style.border = \"1px solid #ccc\";\n  console.log(document.body, document.children, document.children[0])\n  document.body.appendChild(iframe);\n\n  \n\n//   iframe.onload = function () {\nsetTimeout(()=>{\naskTalkai({question: 'hi', content:''})\n},1111)\n\n//   };\n\n\n}\n\nasync function askTalkai(chatInput){\n    \nconst iframe_id_selector = '#myFrame'\n\nconst { question, content } = chatInput;\n\n\nlet prompt = `\nYou extract answers from the provided CONTENT.\n###CONTENT START\n\n${'..'||content}\n\n###CONTENT END\n\n###QUESTION\n\n${question}\n`\n\nconsole.log(prompt,)\n\n\n// Runs in the top page (any injected snippet/file)\nfunction iframeFetch(iframeEl, url, init = {}, targetOrigin = \"*\", timeoutMs = 15000) {\n  if (!iframeEl || !iframeEl.contentWindow) {\n    return Promise.reject(new Error(\"iframe not available\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    const timer = setTimeout(() => {\n      channel.port1.close();\n      reject(new Error(\"iframeFetch timeout\"));\n    }, timeoutMs);\n\n    channel.port1.onmessage = (ev) => {\n      clearTimeout(timer);\n      channel.port1.close();\n      resolve(ev.data);\n    };\n\n    iframeEl.contentWindow.postMessage({\n      type: \"IFRAME_FETCH_REQ\",\n      payload: { url, init }\n    }, targetOrigin, [channel.port2]);\n  });\n}\n\n\nconsole.log('aaa')\n  let res = await iframeFetch(document.querySelector('#myFrame'), \"https://amicidellapallavolo.it/\", { method: \"GET\" }, \"*\")\n    \n\nconsole.log('Result from iframe page-world:', res);\nreturn parseSSE(res.body)\n}\n\nsetTimeout(()=>{\nif(window.location.href==='https://www.google.com/')\n// if(window.location.href==='https://www.amicidellapallavolo.it/login.asp')\n// if(window.location.href==='about:blank')\naddIframe()\n},2222)\n\n","enable":false,"host":"","id":28,"name":"Script27 (copy)","src":"","type":"snippet"},{"code":"function addIframe(url=\"https://talkai.info/chat/\", width = \"600\", height = \"400\") {\n  const iframe = document.createElement(\"iframe\");\n  iframe.id='myFrame'\n  iframe.src = url;\n  iframe.width = width;\n  iframe.height = height;\n  iframe.style.border = \"1px solid #ccc\";\n  console.log(document.body, document.children, document.children[0])\n  document.body.appendChild(iframe);\n\n  \n\n//   iframe.onload = function () {\nsetTimeout(()=>{\naskTalkai({question: 'hi', content:''})\n},1111)\n\n//   };\n\n\n}\n\nasync function askTalkai(chatInput){\n    \nconst iframe_id_selector = '#myFrame'\n\nconst { question, content } = chatInput;\n\n\nlet prompt = `\nYou extract answers from the provided CONTENT.\n###CONTENT START\n\n${'..'||content}\n\n###CONTENT END\n\n###QUESTION\n\n${question}\n`\n\nconsole.log(prompt,)\n\n\n// Runs in the top page (any injected snippet/file)\nfunction iframeFetch(iframeEl, url, init = {}, targetOrigin = \"*\", timeoutMs = 15000) {\n  if (!iframeEl || !iframeEl.contentWindow) {\n    return Promise.reject(new Error(\"iframe not available\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    const timer = setTimeout(() => {\n      channel.port1.close();\n      reject(new Error(\"iframeFetch timeout\"));\n    }, timeoutMs);\n\n    channel.port1.onmessage = (ev) => {\n      clearTimeout(timer);\n      channel.port1.close();\n      resolve(ev.data);\n    };\n\n    iframeEl.contentWindow.postMessage({\n      type: \"IFRAME_FETCH_REQ\",\n      payload: { url, init }\n    }, targetOrigin, [channel.port2]);\n  });\n}\n\n\n\n  let res = await iframeFetch(document.querySelector('#myFrame'), \"https://talkai.info/it/chat/send/\", {\n    method: 'POST',\n    headers: {\n      'accept': 'application/json, text/event-stream',\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      type: 'chat',\n      messagesHistory: [{ id: crypto.randomUUID(), from: 'you', content: prompt }],\n      settings: { model: 'gpt-4.1-nano', temperature: 0.7 }\n    })\n  }, \"*\")\n    \nlet parsed = parseSSE(res.body)\nconsole.log('Result from iframe page-world:', res, parsed);\nreturn parsed\n}\n\nif(window.parent == window){\nsetTimeout(()=>{\n// if(window.location.href==='https://www.google.com/')\n\n// if(window.location.href==='https://www.amicidellapallavolo.it/login.asp')\n// if(window.location.href==='about:blank')\naddIframe()\n},2222)\n}\n\n\nfunction parseSSE(raw) {\n    // What youâ€™re dealing with is Server-Sent Events (SSE), where the server streams chunks prefixed with data:. You want to collect all those fragments until the termination marker event: trylimit.\n  const lines = raw.split(\"\\n\");\n  let output = [];\n\n  for (let line of lines) {\n    // line = line.trim();\n\n    // stop when termination event is reached\n    if (line.startsWith(\"event: trylimit\")) {\n      break;\n    }\n\n    // collect only 'data:' lines\n    if (line.startsWith(\"data:\")) {\n      // const chunk = line.replace(/^data:\\s*/, \"\");\n      const chunk = line.replace(/^data: /, \"\");\n      if (chunk) output.push(chunk);\n    }\n  }\n\n  return output.join(\"\"); // merge into plain string\n}\n\n\n","enable":false,"host":"","id":29,"name":"Script27 (copy 2) --this","src":"","type":"snippet"},{"code":"if(window.parent==window){\n// alert(1)\nasync function askTalkai(chatInput){\n    \n\n\nconst { question, content } = chatInput;\n\n\nlet prompt = `\nYou extract answers from the provided CONTENT.\n###CONTENT START\n\n${content}\n\n###CONTENT END\n\n###QUESTION\n\n${question}\n`\n\nconsole.log(prompt,)\n\n\n// Runs in the top page (any injected snippet/file)\nfunction iframeFetch(iframeEl, url, init = {}, targetOrigin = \"*\", timeoutMs = 15000) {\n  if (!iframeEl || !iframeEl.contentWindow) {\n    return Promise.reject(new Error(\"iframe not available\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    const timer = setTimeout(() => {\n      channel.port1.close();\n      reject(new Error(\"iframeFetch timeout\"));\n    }, timeoutMs);\n\n    channel.port1.onmessage = (ev) => {\n      clearTimeout(timer);\n      channel.port1.close();\n      resolve(ev.data);\n    };\n\n    iframeEl.contentWindow.postMessage({\n      type: \"IFRAME_FETCH_REQ\",\n      payload: { url, init }\n    }, targetOrigin, [channel.port2]);\n  });\n}\n\n\n\n  let res = await iframeFetch(document.querySelector(`#${frame_id}`), \"https://talkai.info/it/chat/send/\", {\n    method: 'POST',\n    headers: {\n      'accept': 'application/json, text/event-stream',\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      type: 'chat',\n      messagesHistory: [{ id: crypto.randomUUID(), from: 'you', content: prompt }],\n      settings: { model: 'gpt-4.1-nano', temperature: 0.7 }\n    })\n  }, \"*\")\n    \nlet parsed = parseSSE(res.body)\nconsole.log('Result from iframe page-world:', res, parsed);\nreturn parsed\n}\n\n\nconst frame_id = 'myFrame__'\n\nconst OLLAMA_BASE = \"http://localhost:11434\";\nconst DEFAULT_MODEL = \"llama3.2\";\n// const DEFAULT_MODEL = \"gemma3:12b\";\n\n// Helper: safe model fallback\nconst pickModel = (m) => m ?? DEFAULT_MODEL;\n\n// Optional: extract <answer>...</answer> for chat responses\nfunction extractAnswerTag(text) {\n  if (!text) return \"\";\n  const start = text.indexOf(\"<answer>\");\n  const end = text.indexOf(\"</answer>\");\n  if (start !== -1 && end !== -1 && end > start) {\n    return text.slice(start + 9, end).trim();\n  }\n  return text.trim();\n}\n\n/**\n * Simple completion call (/api/generate)\n */\nasync function askOllama(prompt, options = {}) {\n  const payload = {\n    model: pickModel(options.model),\n    prompt,\n    stream: options.stream ?? false,\n    ...options,\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/generate`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n    return res; // whatever your apiExt returns (likely parsed JSON)\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/generate:\", err);\n    throw err;\n  }\n}\n\n/**\n * Chat call (/api/chat) using apiExt, mirroring askOllama style\n * @param {{question: string, content: string}} chatInput\n * @param {object} options - same pattern as askOllama\n */\nasync function askOllamaChat(chatInput, options = {}) {\n  const { question, content } = chatInput;\n\n  const messages = [\n    {\n      role: \"system\",\n      content: [\n        // \"You extract answers from the provided CONTENT only.\",\n        \"You extract answers from the provided CONTENT.\",\n        // \"Be concise: <= 100 characters.\",\n        // \"If not found in CONTENT, reply: Not found.\",\n        // \"If not found in CONTENT, reply: No results.\",\n        // \"Output MUST be wrapped in <answer>...</answer> with nothing else.\"\n      ].join(\" \")\n    },\n    {\n      role: \"user\",\n      content: [\n        \"### CONTENT START\",\n        content,\n        \"### CONTENT END\",\n        \"\",\n        \"### QUESTION\",\n        question\n      ].join(\"\\n\")\n    }\n  ];\n\n  const payload = {\n    model: pickModel(options.model),\n    stream: options.stream ?? false,\n    options: {\n      temperature: 0.2,\n      num_ctx: 8192,\n      stop: [\"</answer>\"],\n      ...(options.options || {})\n    },\n    messages,\n    ...options, // allow overriding top-level fields if you really want\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/chat`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n\n    // If you want to directly return parsed text like askOllama does,\n    // you can normalize here. Otherwise, return the raw `res`.\n    // Uncomment to normalize:\n    //\n    // const contentTxt = res?.message?.content ?? \"\";\n    // return { ...res, extracted: extractAnswerTag(contentTxt) };\n\n    return res;\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/chat:\", err);\n    throw err;\n  }\n}\n\n\n\nfunction addIframe(url=\"https://talkai.info/chat/\", width = \"600\", height = \"400\") {\n  const iframe = document.createElement(\"iframe\");\n  iframe.id=frame_id\n  iframe.src = url;\n  iframe.width = width;\n  iframe.height = height;\n  iframe.style.border = \"1px solid #ccc\";\n  iframe.style.display='none'\n  document.body.appendChild(iframe);\n\n  \n\n  iframe.onload = function () {\n    // const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    // // Example: change background\n    // iframeDoc.body.style.backgroundColor = \"lightyellow\";\n    // // Example: insert text\n    // iframeDoc.body.innerHTML += \"<p>Injected from parent page!</p>\";\n  };\n\n}\n\naddIframe();\nconsole.log(addIframe)\n// write here code that injects interface on html page with field for user prompt and a box for stream response from llm\n// (() => {\nalert(1)\n//   addIframe()\n//   const askAI = askOllamaChat;\n  const askAI = askTalkai;\n\n  // ---------- UI Styles ----------\n    // .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    // width:min(520px,95vw);background:#111827;color:#e5e7eb;border:1px solid #1f2937;\n    // border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    // user-select:none}\n  const css = `\n  .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    width:min(520px,95vw);background:#111827dd;color:#e5e7eb;border:1px solid #1f2937;backdrop-filter:blur(7px);\n    border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    user-select:none; resize: both; overflow: hidden; min-width: 250px; min-height: 180px}\n  .agent-ui.dragging{opacity:.95}\n  .agent-ui .hdr{display:flex;align-items:center;gap:8px;padding:10px 12px;border-bottom:1px solid #1f2937;cursor:move}\n  .agent-ui .title{font-weight:600}\n  .agent-ui .body{padding:12px;display:flex;flex-direction:column;gap:10px; user-select:text;height: calc( 100% - 64px )}\n  .agent-ui textarea{width:initial;min-height:12px;height:60px;resize:vertical;background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:10px;outline:none; font-family: sans-serif}\n  .agent-ui .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n  .agent-ui button{background:#2563eb;border:none;color:white;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer; transition: box-shadow 0.15s ease-in-out}\n  .agent-ui button:hover{background:#2563eb;filter: brightness(120%); box-shadow: 0 0 0 2px #6591f1}\n  .agent-ui button:active{background:#2563eb;filter: brightness(80%); box-shadow: 0 0 0 1px #6591f1}\n  .agent-ui button.ghost{background:transparent;color:#cbd5e1;border:1px solid #334155}\n  .agent-ui pre{background:#0b1220;border:1px solid #334155;border-radius:10px;padding:12px;max-height:40vh;overflow:auto;white-space:pre-wrap;word-wrap:break-word; height: 100%}\n  `;\n\n  const style = document.createElement('style');\n  style.textContent = css;\n  document.body.appendChild(style);\n\n// ==================\nfunction drawBox(){\n  const box = document.createElement('div');\nbox.className = 'agent-ui';\nbox.id = 'blower__';\nbox.style.display = 'none';\n\n// Header\nconst header = document.createElement('div');\nheader.className = 'hdr';\n\nconst title = document.createElement('div');\ntitle.className = 'title';\ntitle.textContent = 'Blower';\n\nconst headerRight = document.createElement('div');\nheaderRight.style.marginLeft = 'auto';\nheaderRight.style.display = 'flex';\nheaderRight.style.gap = '6px';\n\nconst clearBtn = document.createElement('button');\nclearBtn.className = 'ghost';\nclearBtn.dataset.action = 'clear';\nclearBtn.textContent = 'Clear';\n\nconst closeBtn = document.createElement('button');\ncloseBtn.className = 'ghost';\ncloseBtn.dataset.action = 'close';\ncloseBtn.textContent = 'âœ•';\n\nheaderRight.append(clearBtn, closeBtn);\nheader.append(title, headerRight);\n\n// Body\nconst body = document.createElement('div');\nbody.className = 'body';\n\nconst flexDiv = document.createElement('div');\nflexDiv.style.display = 'flex';\n\nconst textarea = document.createElement('textarea');\ntextarea.id = 'ask-box';\ntextarea.placeholder = 'Ask me anything...';\n\nconst row = document.createElement('div');\nrow.className = 'row';\n\nconst goBtn = document.createElement('button');\ngoBtn.dataset.action = 'start';\ngoBtn.style.width = '100%';\ngoBtn.textContent = 'Go';\n\nrow.appendChild(goBtn);\n\nconst output = document.createElement('pre');\noutput.id = 'ai-output';\noutput.textContent = 'ðŸ”Ž Ready';\n\n// Put it all together\nbody.append(flexDiv, textarea, row, output);\nbox.append(header, body);\ndocument.body.appendChild(box);\nreturn box\n}\nlet box=drawBox()\n// =====================\n  // Restore saved position (if any)\n  try {\n    // const saved = JSON.parse(localStorage.getItem('agent-ui-pos') || '{}');\n    const saved = {}\n    if (typeof saved.left === 'number' && typeof saved.top === 'number') {\n      box.style.left = saved.left + 'px';\n      box.style.top  = saved.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n    }\n    // const savedVis = localStorage.getItem('agent-ui-visible');\n    const savedVis = 'hidden'\n    if (savedVis === 'hidden') box.style.display = 'none';\n  } catch {}\n\n  // ---------- Helpers ----------\n  const $ = (sel) => box.querySelector(sel);\n  const textarea = $('textarea');\n  const startBtn = $('[data-action=\"start\"]');\n  const clearBtn = $('[data-action=\"clear\"]');\n  const closeBtn = $('[data-action=\"close\"]');\n  const out = $('#ai-output');\n  const header = box.querySelector('.hdr');\n\n  // Drag state\n  let dragging = false;\n  let startX = 0, startY = 0;\n  let boxStartLeft = 0, boxStartTop = 0;\n  let usingLeftTop = false;\n\n  const clamp = (val, min, max) => Math.min(Math.max(val, min), max);\n\n  function ensureLeftTopMode() {\n    if (!usingLeftTop) {\n      const r = box.getBoundingClientRect();\n      box.style.left = r.left + 'px';\n      box.style.top  = r.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n      usingLeftTop = true;\n    }\n  }\n\n  function onPointerDown(clientX, clientY) {\n    dragging = true;\n    ensureLeftTopMode();\n    const r = box.getBoundingClientRect();\n    startX = clientX;\n    startY = clientY;\n    boxStartLeft = r.left;\n    boxStartTop  = r.top;\n    box.classList.add('dragging');\n    // Prevent text selection while dragging\n    document.body.style.userSelect = 'none';\n  }\n\n  function onPointerMove(clientX, clientY) {\n    if (!dragging) return;\n    const dx = clientX - startX;\n    const dy = clientY - startY;\n\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const r = box.getBoundingClientRect();\n    const newLeft = clamp(boxStartLeft + dx, 6, vw - r.width - 6);\n    const newTop  = clamp(boxStartTop  + dy,  6, vh - r.height - 6);\n\n    box.style.left = newLeft + 'px';\n    box.style.top  = newTop  + 'px';\n  }\n\n  function onPointerUp() {\n    if (!dragging) return;\n    dragging = false;\n    box.classList.remove('dragging');\n    document.body.style.userSelect = '';\n    // persist position\n    try {\n      const r = box.getBoundingClientRect();\n      // localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(r.left), top: Math.round(r.top) }));\n    } catch {}\n  }\n\n  // Mouse events\n  header.addEventListener('mousedown', (e) => {\n    if (e.button !== 0) return;\n    onPointerDown(e.clientX, e.clientY);\n    e.preventDefault();\n  });\n  window.addEventListener('mousemove', (e) => onPointerMove(e.clientX, e.clientY));\n  window.addEventListener('mouseup', onPointerUp);\n\n  // Touch events\n  header.addEventListener('touchstart', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerDown(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchmove', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerMove(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchend', onPointerUp);\n\n  // Keep box inside viewport on resize\n  window.addEventListener('resize', () => {\n    const r = box.getBoundingClientRect();\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const left = clamp(r.left, 6, vw - r.width - 6);\n    const top  = clamp(r.top,  6, vh - r.height - 6);\n    box.style.left = left + 'px';\n    box.style.top  = top  + 'px';\n    box.style.right = 'auto';\n    box.style.bottom = 'auto';\n    usingLeftTop = true;\n    try {\n      // localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(left), top: Math.round(top) }));\n    } catch {}\n  });\n\n  // Toggle visibility with Ctrl+Shift+H (or Cmd+Shift+H on mac)\n  function toggleBoxVisibility() {\n    const hidden = box.style.display === 'none';\n    box.style.display = hidden ? '' : 'none';\n    try {\n      // localStorage.setItem('agent-ui-visible', hidden ? 'shown' : 'hidden');\n    } catch {}\n    document.querySelector('#ask-box').focus()\n  }\n  document.addEventListener('keydown', (e) => {\n    const isH = e.key && e.key.toLowerCase() === 'x';\n    if (isH && e.shiftKey && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      toggleBoxVisibility();\n    }\n  });\nfunction processPage() {\n  // ---- 1) Clone the DOM so we never mutate the live page ----\n  const domBody = document.body.cloneNode(true);\n  const doc = document; // baseURI, title, metas come from the live doc\n\n  // ---- 2) Drop obvious junk early (scripts, styles, embeds, tracking, etc.) ----\n  const hardRemoveSelectors = [\n    'script','noscript','style',\n    // 'template',\n    // 'link[rel=\"preload\"]','link[rel=\"modulepreload\"]',\n    // 'iframe',\n    'object','embed','svg','canvas',\n    // 'form','button','select','input','textarea',\n    'video','audio','picture','source',\n    // common boilerplate / chrome\n    'aside',\n    // 'nav','footer','header',\n  ].join(',');\n\n  domBody.querySelectorAll(hardRemoveSelectors).forEach(el => el.remove());\n\n    // Remove specific known elements\n  const blower = domBody.querySelector('#blower__');\n  if (blower) blower.remove();\n  const fr = domBody.querySelector(`#${frame_id}`);\n  if (fr) fr.remove();\n\n\n  // ---- 3) Remove elements by role/semantics or nuisance-y id/class patterns ----\n  const nuisanceRe = /(cookie|consent|gdpr|banner|promo|subscribe|signup|newsletter|metered|paywall|modal|dialog|overlay|popover|tooltip|share|social|related|recommend(ed|ations)?|breadcrumb|nav|sidebar|footer|header|ad(s|vert|vertisement)?|sponsor|tracking|beacon|outbrain|taboola)/i;\n  domBody.querySelectorAll('[role], [id], [class]').forEach(el => {\n    const role = el.getAttribute('role') || '';\n    const id = el.id || '';\n    const cls = el.className || '';\n    if (\n      /^(navigation|banner|complementary|contentinfo|search|dialog|alertdialog|menu|menubar|tablist|toolbar)$/i.test(role) ||\n      nuisanceRe.test(id) ||\n      nuisanceRe.test(String(cls))\n    ) {\n      el.remove();\n    }\n  });\n\n  // ---- 4) Remove hidden/visually suppressed elements ----\n  domBody.querySelectorAll('*').forEach(el => {\n    const s = el.getAttribute('style') || '';\n    if (\n      el.hidden ||\n      el.getAttribute('aria-hidden') === 'true' ||\n      /\\bdisplay\\s*:\\s*none\\b/i.test(s) ||\n      /\\bvisibility\\s*:\\s*hidden\\b/i.test(s) ||\n      /\\bopacity\\s*:\\s*0(\\.0+)?\\b/i.test(s)\n    ) {\n      el.remove();\n    }\n  });\n\n  \n\n  // ---- 5) Remove all HTML comments ----\n  {\n    const walker = document.createTreeWalker(domBody, NodeFilter.SHOW_COMMENT, null, false);\n    const toRemove = [];\n    while (walker.nextNode()) toRemove.push(walker.currentNode);\n    toRemove.forEach(node => node.remove());\n  }\n\n  // ---- 6) Convert images to readable alt text (or drop if useless) ----\n  domBody.querySelectorAll('img').forEach(img => {\n    const alt = (img.getAttribute('alt') || '').trim();\n    if (alt) {\n      img.replaceWith(document.createTextNode(`[Image: ${alt}]`));\n    } else {\n      img.remove();\n    }\n  });\n\n  \n\n  // ---- 7) Expand links to include their (absolute) URLs next to the anchor text ----\n  // domBody.querySelectorAll('a[href]').forEach(a => {\n  //   const href = a.getAttribute('href');\n  //   let abs = '';\n  //   try { abs = new URL(href, doc.baseURI).href; } catch { /* ignore */ }\n  //   const text = (a.textContent || '').trim();\n  //   const label = text && abs ? `${text} (${abs})` : (abs || text);\n  //   a.replaceWith(document.createTextNode(label || ''));\n  // });\n\n  // ---- 8) Light structural flattening: remove leftover UI chrome containers ----\n  // (but keep their text content by unwrapping vs. outright removing)\n  // const unwrapSelectors = ['section','article','main','div','span'];\n  // domBody.querySelectorAll(unwrapSelectors.join(',')).forEach(el => {\n  //   // unwrap shallow, but only if it has no obviously interactive/widgety descendants now\n  //   if (!el.querySelector('button,select,input,textarea,video,audio,iframe,object,embed,svg,canvas')) {\n  //     while (el.firstChild) el.parentNode.insertBefore(el.firstChild, el);\n  //     el.remove();\n  //   }\n  // });\n\n  // ---- 9) Extract meaningful text with gentle block separation ----\n  // Prefer text from common content blocks; fallback to full innerText.\n  const blocks = Array.from(domBody.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,code,table,thead,tbody,tfoot,tr,th,td,caption,span'))\n    .map(el => el.innerText.trim())\n    .filter(Boolean);\n\n  let bodyText = (blocks.length ? blocks.join('\\n\\n') : domBody.innerText || '')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/[ \\t]+\\n/g, '\\n')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n\n    \n\n  // ---- 10) Prepend page metadata (title, canonical URL, description) ----\n  const title = (doc.querySelector('meta[property=\"og:title\"]')?.content || doc.title || '').trim();\n  const canonical = (doc.querySelector('link[rel=\"canonical\"]')?.href || doc.baseURI || '').trim();\n  const description = (doc.querySelector('meta[name=\"description\"]')?.content ||\n                       doc.querySelector('meta[property=\"og:description\"]')?.content || '').trim();\n\n  const headerLines = [];\n  if (title) headerLines.push(`# ${title}`);\n  if (canonical) headerLines.push(canonical);\n  if (description) headerLines.push(`\\n${description}`);\n  const header = headerLines.join('\\n');\n\n  const finalText = [header, bodyText].filter(Boolean).join('\\n\\n').trim();\n\n  return finalText;\n}\nconsole.log(processPage())\n  // ---------- Core ----------\n  async function runPrompt() {\n    const prompt_ = textarea.value.trim();\n    \n\n\n    const content_ = processPage()\n      // .split('\\n')\n      // .map(x => x.length > 100 ? null : x)\n      // .filter(x => x)\n      // .join(' ');\n      console.log(content_)\n\n    let prompt_old = `\n      You are an assistant that extracts information from a webpage. Be short with the answer. Max 50 characters. \n      User question: \"${prompt_}\"  \n\n      Webpage content:  \n      ${content_}\n    `;\n\n    if (!prompt_) {\n      textarea.focus();\n      return;\n    }\n    out.textContent = 'â³ Thinking...';\n    startBtn.disabled = true;\n    textarea.disabled = true;\n\n\n    let question = prompt_;\n    let content = content_;\n\n    try {\n      const res = await askAI({ question, content });\n      console.log(res,'res')\n      out.textContent =\n        typeof res === 'string'\n          ? res\n          : JSON.parse(res.body).message.content;\n    } catch (err) {\n      console.error(err);\n      out.textContent = 'âŒ Error: ' + err.message;\n    } finally {\n      startBtn.disabled = false;\n      textarea.disabled = false;\n    }\n  }\n\n  // ---------- Events ----------\n  startBtn.addEventListener('click', runPrompt);\n  textarea.addEventListener('keydown', (e) => {\n    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {\n      e.preventDefault();\n      runPrompt();\n    }\n  });\n  clearBtn.addEventListener('click', () => { out.textContent = 'ðŸ”Ž Ready'; });\n  closeBtn.addEventListener('click', () => { toggleBoxVisibility(); return; box.remove(); style.remove(); });\n// })();\n\n\n\n\n\nfunction parseSSE(raw) {\n    // What youâ€™re dealing with is Server-Sent Events (SSE), where the server streams chunks prefixed with data:. You want to collect all those fragments until the termination marker event: trylimit.\n  const lines = raw.split(\"\\n\");\n  let output = [];\n\n  for (let line of lines) {\n    // line = line.trim();\n\n    // stop when termination event is reached\n    if (line.startsWith(\"event: trylimit\")) {\n      break;\n    }\n\n    // collect only 'data:' lines\n    if (line.startsWith(\"data:\")) {\n      // const chunk = line.replace(/^data:\\s*/, \"\");\n      const chunk = line.replace(/^data: /, \"\");\n      if (chunk) output.push(chunk);\n    }\n  }\n\n  return output.join(\"\").replaceAll('\\\\n','\\n'); // merge into plain string\n}\n}\n","enable":false,"host":"","id":30,"name":"Script27 (copy 3)","src":"","type":"snippet"},{"code":"\n\nif(window === window.parent){\n\nalert(323)\n\nasync function askTalkai(chatInput){\n    \n\n\nconst { question, content } = chatInput;\n\n\nlet prompt = `\nYou extract answers from the provided CONTENT.\n###CONTENT START\n\n${content}\n\n###CONTENT END\n\n###QUESTION\n\n${question}\n`\n\nconsole.log(prompt,)\n\n\n// Runs in the top page (any injected snippet/file)\nfunction iframeFetch(iframeEl, url, init = {}, targetOrigin = \"*\", timeoutMs = 15000) {\n  if (!iframeEl || !iframeEl.contentWindow) {\n    return Promise.reject(new Error(\"iframe not available\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    const timer = setTimeout(() => {\n      channel.port1.close();\n      reject(new Error(\"iframeFetch timeout\"));\n    }, timeoutMs);\n\n    channel.port1.onmessage = (ev) => {\n      clearTimeout(timer);\n      channel.port1.close();\n      resolve(ev.data);\n    };\n\n    iframeEl.contentWindow.postMessage({\n      type: \"IFRAME_FETCH_REQ\",\n      payload: { url, init }\n    }, targetOrigin, [channel.port2]);\n  });\n}\n\n\n\n  let res = await iframeFetch(document.querySelector(`#${frame_id}`), \"https://talkai.info/it/chat/send/\", {\n    method: 'POST',\n    headers: {\n      'accept': 'application/json, text/event-stream',\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      type: 'chat',\n      messagesHistory: [{ id: crypto.randomUUID(), from: 'you', content: prompt }],\n      settings: { model: 'gpt-4.1-nano', temperature: 0.7 }\n    })\n  }, \"*\")\n    \nlet parsed = parseSSE(res.body)\nconsole.log('Result from iframe page-world:', res, parsed);\nreturn parsed\n}\n\n\nconst frame_id = 'myFrame__'\n\nconst OLLAMA_BASE = \"http://localhost:11434\";\nconst DEFAULT_MODEL = \"llama3.2\";\n// const DEFAULT_MODEL = \"gemma3:12b\";\n\n// Helper: safe model fallback\nconst pickModel = (m) => m ?? DEFAULT_MODEL;\n\n// Optional: extract <answer>...</answer> for chat responses\nfunction extractAnswerTag(text) {\n  if (!text) return \"\";\n  const start = text.indexOf(\"<answer>\");\n  const end = text.indexOf(\"</answer>\");\n  if (start !== -1 && end !== -1 && end > start) {\n    return text.slice(start + 9, end).trim();\n  }\n  return text.trim();\n}\n\n/**\n * Simple completion call (/api/generate)\n */\nasync function askOllama(prompt, options = {}) {\n  const payload = {\n    model: pickModel(options.model),\n    prompt,\n    stream: options.stream ?? false,\n    ...options,\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/generate`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n    return res; // whatever your apiExt returns (likely parsed JSON)\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/generate:\", err);\n    throw err;\n  }\n}\n\n/**\n * Chat call (/api/chat) using apiExt, mirroring askOllama style\n * @param {{question: string, content: string}} chatInput\n * @param {object} options - same pattern as askOllama\n */\nasync function askOllamaChat(chatInput, options = {}) {\n  const { question, content } = chatInput;\n\n  const messages = [\n    {\n      role: \"system\",\n      content: [\n        // \"You extract answers from the provided CONTENT only.\",\n        \"You extract answers from the provided CONTENT.\",\n        // \"Be concise: <= 100 characters.\",\n        // \"If not found in CONTENT, reply: Not found.\",\n        // \"If not found in CONTENT, reply: No results.\",\n        // \"Output MUST be wrapped in <answer>...</answer> with nothing else.\"\n      ].join(\" \")\n    },\n    {\n      role: \"user\",\n      content: [\n        \"### CONTENT START\",\n        content,\n        \"### CONTENT END\",\n        \"\",\n        \"### QUESTION\",\n        question\n      ].join(\"\\n\")\n    }\n  ];\n\n  const payload = {\n    model: pickModel(options.model),\n    stream: options.stream ?? false,\n    options: {\n      temperature: 0.2,\n      num_ctx: 8192,\n      stop: [\"</answer>\"],\n      ...(options.options || {})\n    },\n    messages,\n    ...options, // allow overriding top-level fields if you really want\n  };\n\n  try {\n    const res = await apiExt(\n      `${OLLAMA_BASE}/api/chat`,\n      \"POST\",\n      { \"Content-Type\": \"application/json\" },\n      JSON.stringify(payload)\n    );\n\n    // If you want to directly return parsed text like askOllama does,\n    // you can normalize here. Otherwise, return the raw `res`.\n    // Uncomment to normalize:\n    //\n    // const contentTxt = res?.message?.content ?? \"\";\n    // return { ...res, extracted: extractAnswerTag(contentTxt) };\n\n    return res;\n  } catch (err) {\n    console.error(\"Error calling Ollama /api/chat:\", err);\n    throw err;\n  }\n}\n\n\n\nfunction addIframe(url=\"https://talkai.info/chat/\", width = \"600\", height = \"400\") {\n  const iframe = document.createElement(\"iframe\");\n  iframe.id=frame_id\n  iframe.src = url;\n  iframe.width = width;\n  iframe.height = height;\n  iframe.style.border = \"1px solid #ccc\";\n  iframe.style.display='none'\n  document.body.appendChild(iframe);\n\n  \n\n  iframe.onload = function () {\n    // const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    // // Example: change background\n    // iframeDoc.body.style.backgroundColor = \"lightyellow\";\n    // // Example: insert text\n    // iframeDoc.body.innerHTML += \"<p>Injected from parent page!</p>\";\n  };\n\n}\n\n\naddIframe();\n\n// write here code that injects interface on html page with field for user prompt and a box for stream response from llm\n(() => {\n\n//   addIframe()\n//   const askAI = askOllamaChat;\n  const askAI = askTalkai;\n\n  // ---------- UI Styles ----------\n    // .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    // width:min(520px,95vw);background:#111827;color:#e5e7eb;border:1px solid #1f2937;\n    // border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    // user-select:none}\n  const css = `\n  .agent-ui{position:fixed;right:16px;bottom:16px;z-index:999999;\n    width:min(520px,95vw);background:#111827dd;color:#e5e7eb;border:1px solid #1f2937;backdrop-filter:blur(7px);\n    border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px/1.4 system-ui;\n    user-select:none; resize: both; overflow: hidden; min-width: 250px; min-height: 180px}\n  .agent-ui.dragging{opacity:.95}\n  .agent-ui .hdr{display:flex;align-items:center;gap:8px;padding:10px 12px;border-bottom:1px solid #1f2937;cursor:move}\n  .agent-ui .title{font-weight:600}\n  .agent-ui .body{padding:12px;display:flex;flex-direction:column;gap:10px; user-select:text;height: calc( 100% - 64px )}\n  .agent-ui textarea{width:initial;min-height:12px;height:60px;resize:vertical;background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:10px;outline:none; font-family: sans-serif}\n  .agent-ui .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n  .agent-ui button{background:#2563eb;border:none;color:white;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer; transition: box-shadow 0.15s ease-in-out}\n  .agent-ui button:hover{background:#2563eb;filter: brightness(120%); box-shadow: 0 0 0 2px #6591f1}\n  .agent-ui button:active{background:#2563eb;filter: brightness(80%); box-shadow: 0 0 0 1px #6591f1}\n  .agent-ui button.ghost{background:transparent;color:#cbd5e1;border:1px solid #334155}\n  .agent-ui pre{background:#0b1220;border:1px solid #334155;border-radius:10px;padding:12px;max-height:40vh;overflow:auto;white-space:pre-wrap;word-wrap:break-word; height: 100%}\n  `;\n\n  const style = document.createElement('style');\n  style.textContent = css;\n  document.body.appendChild(style);\n\n  // const box = document.createElement('div');\n  // box.className = 'agent-ui';\n  // box.id = 'blower__';\n  // box.style.display='none'\n  // box.innerHTML = `\n  //   <div class=\"hdr\">\n  //     <div class=\"title\">Blower</div>\n  //     <div style=\"margin-left:auto;display:flex;gap:6px\">\n  //       <button class=\"ghost\" data-action=\"clear\">Clear</button>\n  //       <button class=\"ghost\" data-action=\"close\">âœ•</button>\n  //     </div>\n  //   </div>\n  //   <div class=\"body\">\n  //     <div style=\"display:flex\"></div>\n  //     <textarea id=\"ask-box\" placeholder=\"Ask me anything...\"></textarea>\n  //     <div class=\"row\">\n  //       <button data-action=\"start\" style=\"width: 100%\">Go</button>\n  //     </div>\n  //     <pre id=\"ai-output\">ðŸ”Ž Ready</pre>\n  //   </div>\n  // `;\n  // document.body.appendChild(box);\n\n  // ==================\nfunction drawBox(){\n  const box = document.createElement('div');\nbox.className = 'agent-ui';\nbox.id = 'blower__';\nbox.style.display = 'none';\n\n// Header\nconst header = document.createElement('div');\nheader.className = 'hdr';\n\nconst title = document.createElement('div');\ntitle.className = 'title';\ntitle.textContent = 'Blower';\n\nconst headerRight = document.createElement('div');\nheaderRight.style.marginLeft = 'auto';\nheaderRight.style.display = 'flex';\nheaderRight.style.gap = '6px';\n\nconst clearBtn = document.createElement('button');\nclearBtn.className = 'ghost';\nclearBtn.dataset.action = 'clear';\nclearBtn.textContent = 'Clear';\n\nconst closeBtn = document.createElement('button');\ncloseBtn.className = 'ghost';\ncloseBtn.dataset.action = 'close';\ncloseBtn.textContent = 'âœ•';\n\nheaderRight.append(clearBtn, closeBtn);\nheader.append(title, headerRight);\n\n// Body\nconst body = document.createElement('div');\nbody.className = 'body';\n\nconst flexDiv = document.createElement('div');\nflexDiv.style.display = 'flex';\n\nconst textarea = document.createElement('textarea');\ntextarea.id = 'ask-box';\ntextarea.placeholder = 'Ask me anything...';\n\nconst row = document.createElement('div');\nrow.className = 'row';\n\nconst goBtn = document.createElement('button');\ngoBtn.dataset.action = 'start';\ngoBtn.style.width = '100%';\ngoBtn.textContent = 'Go';\n\nrow.appendChild(goBtn);\n\nconst output = document.createElement('pre');\noutput.id = 'ai-output';\noutput.textContent = 'ðŸ”Ž Ready';\n\n// Put it all together\nbody.append(flexDiv, textarea, row, output);\nbox.append(header, body);\ndocument.body.appendChild(box);\nreturn box\n}\nlet box=drawBox()\n\n\n  // Restore saved position (if any)\n  try {\n    // const saved = JSON.parse(localStorage.getItem('agent-ui-pos') || '{}');\n    const saved = {}\n    if (typeof saved.left === 'number' && typeof saved.top === 'number') {\n      box.style.left = saved.left + 'px';\n      box.style.top  = saved.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n    }\n    // const savedVis = localStorage.getItem('agent-ui-visible');\n    const savedVis = 'hidden'\n    if (savedVis === 'hidden') box.style.display = 'none';\n  } catch {}\n\n  // ---------- Helpers ----------\n  const $ = (sel) => box.querySelector(sel);\n  const textarea = $('textarea');\n  const startBtn = $('[data-action=\"start\"]');\n  const clearBtn = $('[data-action=\"clear\"]');\n  const closeBtn = $('[data-action=\"close\"]');\n  const out = $('#ai-output');\n  const header = box.querySelector('.hdr');\n\n  // Drag state\n  let dragging = false;\n  let startX = 0, startY = 0;\n  let boxStartLeft = 0, boxStartTop = 0;\n  let usingLeftTop = false;\n\n  const clamp = (val, min, max) => Math.min(Math.max(val, min), max);\n\n  function ensureLeftTopMode() {\n    if (!usingLeftTop) {\n      const r = box.getBoundingClientRect();\n      box.style.left = r.left + 'px';\n      box.style.top  = r.top  + 'px';\n      box.style.right = 'auto';\n      box.style.bottom = 'auto';\n      usingLeftTop = true;\n    }\n  }\n\n  function onPointerDown(clientX, clientY) {\n    dragging = true;\n    ensureLeftTopMode();\n    const r = box.getBoundingClientRect();\n    startX = clientX;\n    startY = clientY;\n    boxStartLeft = r.left;\n    boxStartTop  = r.top;\n    box.classList.add('dragging');\n    // Prevent text selection while dragging\n    document.body.style.userSelect = 'none';\n  }\n\n  function onPointerMove(clientX, clientY) {\n    if (!dragging) return;\n    const dx = clientX - startX;\n    const dy = clientY - startY;\n\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const r = box.getBoundingClientRect();\n    const newLeft = clamp(boxStartLeft + dx, 6, vw - r.width - 6);\n    const newTop  = clamp(boxStartTop  + dy,  6, vh - r.height - 6);\n\n    box.style.left = newLeft + 'px';\n    box.style.top  = newTop  + 'px';\n  }\n\n  function onPointerUp() {\n    if (!dragging) return;\n    dragging = false;\n    box.classList.remove('dragging');\n    document.body.style.userSelect = '';\n    // persist position\n    try {\n      const r = box.getBoundingClientRect();\n      // localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(r.left), top: Math.round(r.top) }));\n    } catch {}\n  }\n\n  // Mouse events\n  header.addEventListener('mousedown', (e) => {\n    if (e.button !== 0) return;\n    onPointerDown(e.clientX, e.clientY);\n    e.preventDefault();\n  });\n  window.addEventListener('mousemove', (e) => onPointerMove(e.clientX, e.clientY));\n  window.addEventListener('mouseup', onPointerUp);\n\n  // Touch events\n  header.addEventListener('touchstart', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerDown(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchmove', (e) => {\n    const t = e.touches[0];\n    if (!t) return;\n    onPointerMove(t.clientX, t.clientY);\n  }, { passive: true });\n  window.addEventListener('touchend', onPointerUp);\n\n  // Keep box inside viewport on resize\n  window.addEventListener('resize', () => {\n    const r = box.getBoundingClientRect();\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n    const left = clamp(r.left, 6, vw - r.width - 6);\n    const top  = clamp(r.top,  6, vh - r.height - 6);\n    box.style.left = left + 'px';\n    box.style.top  = top  + 'px';\n    box.style.right = 'auto';\n    box.style.bottom = 'auto';\n    usingLeftTop = true;\n    try {\n      // localStorage.setItem('agent-ui-pos', JSON.stringify({ left: Math.round(left), top: Math.round(top) }));\n    } catch {}\n  });\n\n  // Toggle visibility with Ctrl+Shift+H (or Cmd+Shift+H on mac)\n  function toggleBoxVisibility() {\n    const hidden = box.style.display === 'none';\n    box.style.display = hidden ? '' : 'none';\n    try {\n      // localStorage.setItem('agent-ui-visible', hidden ? 'shown' : 'hidden');\n    } catch {}\n    document.querySelector('#ask-box').focus()\n  }\n  document.addEventListener('keydown', (e) => {\n    const isH = e.key && e.key.toLowerCase() === 'x';\n    if (isH && e.shiftKey && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      toggleBoxVisibility();\n    }\n  });\nfunction processPage() {\n  // ---- 1) Clone the DOM so we never mutate the live page ----\n  const domBody = document.body.cloneNode(true);\n  const doc = document; // baseURI, title, metas come from the live doc\n\n  // ---- 2) Drop obvious junk early (scripts, styles, embeds, tracking, etc.) ----\n  const hardRemoveSelectors = [\n    'script','noscript','style',\n    // 'template',\n    // 'link[rel=\"preload\"]','link[rel=\"modulepreload\"]',\n    // 'iframe',\n    'object','embed','svg','canvas',\n    // 'form','button','select','input','textarea',\n    'video','audio','picture','source',\n    // common boilerplate / chrome\n    'aside',\n    // 'nav','footer','header',\n  ].join(',');\n\n  domBody.querySelectorAll(hardRemoveSelectors).forEach(el => el.remove());\n\n    // Remove specific known elements\n  const blower = domBody.querySelector('#blower__');\n  if (blower) blower.remove();\n  const fr = domBody.querySelector(`#${frame_id}`);\n  if (fr) fr.remove();\n\n\n  // ---- 3) Remove elements by role/semantics or nuisance-y id/class patterns ----\n  const nuisanceRe = /(cookie|consent|gdpr|banner|promo|subscribe|signup|newsletter|metered|paywall|modal|dialog|overlay|popover|tooltip|share|social|related|recommend(ed|ations)?|breadcrumb|nav|sidebar|footer|header|ad(s|vert|vertisement)?|sponsor|tracking|beacon|outbrain|taboola)/i;\n  domBody.querySelectorAll('[role], [id], [class]').forEach(el => {\n    const role = el.getAttribute('role') || '';\n    const id = el.id || '';\n    const cls = el.className || '';\n    if (\n      /^(navigation|banner|complementary|contentinfo|search|dialog|alertdialog|menu|menubar|tablist|toolbar)$/i.test(role) ||\n      nuisanceRe.test(id) ||\n      nuisanceRe.test(String(cls))\n    ) {\n      el.remove();\n    }\n  });\n\n  // ---- 4) Remove hidden/visually suppressed elements ----\n  domBody.querySelectorAll('*').forEach(el => {\n    const s = el.getAttribute('style') || '';\n    if (\n      el.hidden ||\n      el.getAttribute('aria-hidden') === 'true' ||\n      /\\bdisplay\\s*:\\s*none\\b/i.test(s) ||\n      /\\bvisibility\\s*:\\s*hidden\\b/i.test(s) ||\n      /\\bopacity\\s*:\\s*0(\\.0+)?\\b/i.test(s)\n    ) {\n      el.remove();\n    }\n  });\n\n  \n\n  // ---- 5) Remove all HTML comments ----\n  {\n    const walker = document.createTreeWalker(domBody, NodeFilter.SHOW_COMMENT, null, false);\n    const toRemove = [];\n    while (walker.nextNode()) toRemove.push(walker.currentNode);\n    toRemove.forEach(node => node.remove());\n  }\n\n  // ---- 6) Convert images to readable alt text (or drop if useless) ----\n  domBody.querySelectorAll('img').forEach(img => {\n    const alt = (img.getAttribute('alt') || '').trim();\n    if (alt) {\n      img.replaceWith(document.createTextNode(`[Image: ${alt}]`));\n    } else {\n      img.remove();\n    }\n  });\n\n  \n\n  // ---- 7) Expand links to include their (absolute) URLs next to the anchor text ----\n  // domBody.querySelectorAll('a[href]').forEach(a => {\n  //   const href = a.getAttribute('href');\n  //   let abs = '';\n  //   try { abs = new URL(href, doc.baseURI).href; } catch { /* ignore */ }\n  //   const text = (a.textContent || '').trim();\n  //   const label = text && abs ? `${text} (${abs})` : (abs || text);\n  //   a.replaceWith(document.createTextNode(label || ''));\n  // });\n\n  // ---- 8) Light structural flattening: remove leftover UI chrome containers ----\n  // (but keep their text content by unwrapping vs. outright removing)\n  // const unwrapSelectors = ['section','article','main','div','span'];\n  // domBody.querySelectorAll(unwrapSelectors.join(',')).forEach(el => {\n  //   // unwrap shallow, but only if it has no obviously interactive/widgety descendants now\n  //   if (!el.querySelector('button,select,input,textarea,video,audio,iframe,object,embed,svg,canvas')) {\n  //     while (el.firstChild) el.parentNode.insertBefore(el.firstChild, el);\n  //     el.remove();\n  //   }\n  // });\n\n  // ---- 9) Extract meaningful text with gentle block separation ----\n  // Prefer text from common content blocks; fallback to full innerText.\n  const blocks = Array.from(domBody.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,code,table,thead,tbody,tfoot,tr,th,td,caption,span'))\n    .map(el => el.innerText.trim())\n    .filter(Boolean);\n\n  let bodyText = (blocks.length ? blocks.join('\\n\\n') : domBody.innerText || '')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/[ \\t]+\\n/g, '\\n')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n\n    \n\n  // ---- 10) Prepend page metadata (title, canonical URL, description) ----\n  const title = (doc.querySelector('meta[property=\"og:title\"]')?.content || doc.title || '').trim();\n  const canonical = (doc.querySelector('link[rel=\"canonical\"]')?.href || doc.baseURI || '').trim();\n  const description = (doc.querySelector('meta[name=\"description\"]')?.content ||\n                       doc.querySelector('meta[property=\"og:description\"]')?.content || '').trim();\n\n  const headerLines = [];\n  if (title) headerLines.push(`# ${title}`);\n  if (canonical) headerLines.push(canonical);\n  if (description) headerLines.push(`\\n${description}`);\n  const header = headerLines.join('\\n');\n\n  const finalText = [header, bodyText].filter(Boolean).join('\\n\\n').trim();\n\n  return finalText;\n}\nconsole.log(processPage())\n  // ---------- Core ----------\n  async function runPrompt() {\n    const prompt_ = textarea.value.trim();\n    \n\n\n    const content_ = processPage()\n      // .split('\\n')\n      // .map(x => x.length > 100 ? null : x)\n      // .filter(x => x)\n      // .join(' ');\n      console.log(content_)\n\n    let prompt_old = `\n      You are an assistant that extracts information from a webpage. Be short with the answer. Max 50 characters. \n      User question: \"${prompt_}\"  \n\n      Webpage content:  \n      ${content_}\n    `;\n\n    if (!prompt_) {\n      textarea.focus();\n      return;\n    }\n    out.textContent = 'â³ Thinking...';\n    startBtn.disabled = true;\n    textarea.disabled = true;\n\n\n    let question = prompt_;\n    let content = content_;\n\n    try {\n      const res = await askAI({ question, content });\n      console.log(res,'res')\n      out.textContent =\n        typeof res === 'string'\n          ? res\n          : JSON.parse(res.body).message.content;\n    } catch (err) {\n      console.error(err);\n      out.textContent = 'âŒ Error: ' + err.message;\n    } finally {\n      startBtn.disabled = false;\n      textarea.disabled = false;\n    }\n  }\n\n  // ---------- Events ----------\n  startBtn.addEventListener('click', runPrompt);\n  textarea.addEventListener('keydown', (e) => {\n    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {\n      e.preventDefault();\n      runPrompt();\n    }\n  });\n  clearBtn.addEventListener('click', () => { out.textContent = 'ðŸ”Ž Ready'; });\n  closeBtn.addEventListener('click', () => { toggleBoxVisibility(); return; box.remove(); style.remove(); });\n})();\n\n\n\n\n\nfunction parseSSE(raw) {\n    // What youâ€™re dealing with is Server-Sent Events (SSE), where the server streams chunks prefixed with data:. You want to collect all those fragments until the termination marker event: trylimit.\n  const lines = raw.split(\"\\n\");\n  let output = [];\n\n  for (let line of lines) {\n    // line = line.trim();\n\n    // stop when termination event is reached\n    if (line.startsWith(\"event: trylimit\")) {\n      break;\n    }\n\n    // collect only 'data:' lines\n    if (line.startsWith(\"data:\")) {\n      // const chunk = line.replace(/^data:\\s*/, \"\");\n      const chunk = line.replace(/^data: /, \"\");\n      if (chunk) output.push(chunk);\n    }\n  }\n\n  return output.join(\"\").replaceAll('\\\\n','\\n'); // merge into plain string\n}\n\n}","enable":false,"host":"","id":31,"name":"Script31","src":"","type":"snippet"},{"code":"","enable":true,"host":"","id":32,"name":"Script32","src":"http://localhost:8080/js/applets/llm.js","type":"external"}],"options":{"exclude":""}}